/* Generated by Together */

#include "CRoute.h"
#include "CWaypoint.h"

#include <iostream>
#include <string>
using namespace std;

CRoute::CRoute() {

	// Initializing the attributes
	m_WpCount=0;
	m_PoiCount=0;
	m_pPoiDatabase=NULL;
	m_pWpDatabase=NULL;
}

CRoute::~CRoute(){
	//CRoute destructor
}

void CRoute::connectToPoiDatabase(CPoiDatabase* pPoiDB){

	//linking with POI database
	m_pPoiDatabase=pPoiDB;
}

void CRoute::connectToWpDatabase(CWpDatabase* pWpDB) {

	//linking with Waypoint database
	m_pWpDatabase=pWpDB;
}


void CRoute::addWaypoint(string name) {

	CWaypoint * checkWaypoint;

	// Checking if Waypoint Database present and linked
	if(m_pWpDatabase != NULL)
	{
		checkWaypoint = m_pWpDatabase->getPointerToWaypoint(name);

		// Checking if Waypoint present in Waypoint database
		if(checkWaypoint !=NULL)
		{
			if(checkWaypoint == *(--m_RouteList.end()))
			{
				// user trying to enter same waypoint back to back
		//		cout<<"Error : Waypoint not added to route, previous waypoint entry is the same"<<endl;
			}

			else
			{
				// Waypoint present in data pool, not same as previous waypoint entry - add it to route
				m_RouteList.push_back(checkWaypoint);
				m_WpCount++;
			}
		}

		else
		{
			// Waypoint not in Database
			cout << "Waypoint cannot be added, Waypoint not available in waypoint Database" << endl;
		}
	}

	else
	{
		// Waypoint Database not present or linked
		cout << "Waypoint Database missing" << endl;
	}
}

void CRoute::addPoi(string namePoi, string afterWp) {

	CPOI * checkPoi;
	list <CWaypoint*>::iterator it_Waypoint;

	int wpPresent=0;

	// Checking if both Database present and linked
	if ((m_pPoiDatabase != NULL)&&(m_pWpDatabase != NULL))

	{
		checkPoi = m_pPoiDatabase->getPointerToPoi(namePoi);

		// Checking if POI present in POI database
		if (checkPoi != NULL)
		{
			// POI present in data pool
			// resolving location of waypoint in route list, if multiple entries of waypoint, the last one taken
			for(m_it = m_RouteList.begin(); m_it != m_RouteList.end(); ++m_it )
			{
				//Checking if Waypoint with name afterWp is present in Route list
               if(((*m_it)->getName() == afterWp) && (dynamic_cast<CPOI*>(*m_it)==NULL))
               {
            	   it_Waypoint = m_it;   // updating it_Waypoint with location of waypoint in route list
            	   wpPresent++;  // increments for each waypoint hits in route
               }
			}

			//if waypoint is not in route list - warn the user
			if(wpPresent == 0)
			{
				cout<<"Warning : NO Waypoint/Specified Waypoint present in Route list, POI cannot be added"<<endl;
			}

			//if waypoint is in route list
			else
			{
				// Checking for similar POI entry just after the waypoint
                if (checkPoi == *(++it_Waypoint))
                {
              //  	cout<<"POI already present after the selected waypoint"<<endl;
                }
                else
                {
                	// Enter POI to route list after the waypoint
                	m_RouteList.insert(it_Waypoint,checkPoi);
                	m_PoiCount++;
                }
			}
		}

		else
		{
			// POI not in Database
			cout << "POI cannot be added, POI not available in POI Database " << endl;
		}
	}

	else
	{
		// POI or waypoint Database not present or linked
		cout << "POI cannot be added to route, POI or waypoint Database missing" << endl;
	}

}

CRoute::CRoute(const CRoute& origin) {
	// Copy constructor
	m_WpCount=origin.m_WpCount;
	m_PoiCount=origin.m_PoiCount;
	m_pWpDatabase=origin.m_pWpDatabase;
	m_pPoiDatabase=origin.m_pPoiDatabase;

	m_RouteList=origin.m_RouteList;
	m_it=origin.m_it;
}

double CRoute::getDistanceNextPoi(CWaypoint const & wp, CPOI& poi){

	//resolving the closest POI from current position

	double minDist = -1;
	unsigned int firstPOI = 0;

/*	// Check if no POI in route or POI database is missing
	if(m_PoiCount==0 && m_pPoiDatabase!=NULL)
	{
	//	cout << "Error: no POI found in selected route" << endl;
	//	minDist = -1; // minDist assigned with a negative value for POI database link check
	}*/


	//if we have POIs in our route
	if(m_pPoiDatabase!=NULL)
	{
		for (m_it = m_RouteList.begin(); m_it != m_RouteList.end(); ++m_it)
		{
			CPOI *temp = dynamic_cast<CPOI*>(*m_it);

			if((temp!=NULL) && firstPOI == 0)
			{
				// Temporarily assigning minimum distance to that of first POi in route list
				minDist=temp->calculateDistance(wp);
				++firstPOI;
				poi=*temp;
			}

			if(temp!=NULL)   // iterator now holds a POI pointer
			{
				if(minDist > temp->calculateDistance(wp))
				{
					// Modifying minimum distance if nearer POi found in list
					minDist=temp->calculateDistance(wp);
					poi=*temp;
				}
			}
		}

		//return (minDist);
	}
	//Returning distance to the closest POI from current position
	return (minDist);

}


void CRoute::print(){

	cout<<endl<<"The Route has "<<m_WpCount<<" Waypoints and "<<m_PoiCount<<" POIs"<<endl;

	// Printing route list
	for (m_it = m_RouteList.begin(); m_it != m_RouteList.end(); ++m_it)
	{
		cout<<endl;  //output formating
//		(**m_it).print(DMS);
//		cout<<(**m_it)<<endl; // No match for operator<< error - if not overloaded
		if(dynamic_cast<CPOI*>(*m_it)!=NULL)
		{
           cout<<*(dynamic_cast<CPOI*>(*m_it));
		}
		else
		{
          cout<<**m_it;
		}
	}

	cout<<endl<<"------------------------------------------------------------------------------"<<endl;
}

void CRoute::operator= (CRoute R1){
	// Implementing assignment operator for Route
	this->m_WpCount = R1.m_WpCount;
	this->m_PoiCount = R1.m_PoiCount;
	this->m_pWpDatabase = R1.m_pWpDatabase;
	this->m_pPoiDatabase = R1.m_pPoiDatabase;

	// Copying list - route list
	this->m_RouteList = R1.m_RouteList;
	this->m_it = R1.m_it;
}

void CRoute::operator +=(string name) {

	//Overloaded += operator - add poi extension to add waypoint or poi without any constraints to route

	// Check and add Waypoint if all addWaypoint conditions are met
	this->addWaypoint(name);

	// Check and add POI if all addPoi conditions are met
	this->addPoi(name, name);

	// Add POI to end of route if above two fails
	CPOI * checkPoi;
	if ((m_pPoiDatabase != NULL) && (m_pWpDatabase != NULL))
	{
		checkPoi = m_pPoiDatabase->getPointerToPoi(name);

		// Checking if POI present in POI database and is not at end of route list
		if (checkPoi != NULL && checkPoi != *(--m_RouteList.end()))
		{
			m_RouteList.push_back(checkPoi);
		}
	}
}


CRoute CRoute::operator +(CRoute object) {

	// adding to routes together
	CRoute r;

	// Checking if databases of both routes are similar
	if((m_pPoiDatabase==object.m_pPoiDatabase)&&(m_pWpDatabase==object.m_pWpDatabase))
	{
		m_RouteList.insert(m_RouteList.end(),object.m_RouteList.begin(),object.m_RouteList.end());
		return(*this);
	}
	else
	{
		// different databases, so avoid addition of routes
		cout<<"Error : Route cannot be added, database mismatch"<<endl;
		return(r);
	}
}

void CRoute::clearRoute(){
	m_RouteList.clear();
}

vector<const CWaypoint*> CRoute::getRoute() const
{
	vector<const CWaypoint*> routeTest;

	list<CWaypoint*>::const_iterator itr;
	for(itr = m_RouteList.begin(); itr != m_RouteList.end(); ++itr )
	{
		routeTest.push_back(*itr);
	}
	return routeTest;
}
